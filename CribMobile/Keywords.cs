using System.Collections.Generic;
using Android.App;
using Android.OS;
using Android.Views;
using Android.Widget;
using Android.Graphics;

namespace CsharpKeyWords
{
    [Activity(Label = "Keywords")]
    public class Keywords : Activity
    {
		private Button oldBtn;
		private Button oldBtn2;

        protected override void OnCreate(Bundle savedInstanceState)
        {
            base.OnCreate(savedInstanceState);
			SetContentView(Resource.Layout.Keywords);
            // Create your application here
			oldBtn = FindViewById<Button>(Resource.Id.button15);
            oldBtn2 = FindViewById<Button>(Resource.Id.button1);
        }
		 
        internal readonly Dictionary<int, string> Typesstr = new Dictionary<int, string>()
        {
            {0,"bool"} , {1,"byte"}, {2,"char"},{3,"decimal"},{4, "double"}, {5 , "enum"}, {6 , "float"}, {7  , "int" }, { 8, "long" },
            {9 ,"sbyte" }, {10,  "short" }, {11, "struct"  },{12 , "uint" }, {13 ,"ulong" },
            {14,"ushort"}, {15 ,"class" }, {16,"delegate"}, {17,"dynamic"}, {18,"interface" }, {19, "object"}, {20,"string" },{21,"void" },
            {22,"var" }

        };

        internal readonly Dictionary<int, string> Modifiers = new Dictionary<int, string>()
        {   {23, "abstract"}, {24, "async"}, {25, "const"}, {26, "event"}, {27,"extern"}, {28, "in"}, {29, "out"}, {30 ,"override"},
            {31,"readonly"}, {32,"sealed"}, {33,"static"} , {34, "unsafe"}, {35, "virtual"}, {36,"volatile"}
        };

        internal readonly Dictionary<int, string> Statement = new Dictionary<int, string>()
        {
            {37,  "if-else"}, {38,"switch" }, {39,"do" }, {40,"for" }, {41, "foreach, in"}, {42,"while" }, {43,"break" }, {44,"continue" }, {45,"goto" }, {46,"return" }
            , {47, "throw"},{48,"try-catch" }, {49,  "try-finally"}, {50, "try-catch-finally"}, {51,"checked" }, {52,"unchecked" }, {53,"fixed" }, {54,"lock" }
        };

        internal readonly Dictionary<int, string> Method = new Dictionary<int, string>() { { 55, "params" }, { 56, "ref" }, { 57, "out" } };
        internal readonly Dictionary<int, string> Namespace = new Dictionary<int, string>() { { 58, "namespace" }, { 59, "using Directive" }, { 60, " using Statement" } };

        internal readonly Dictionary<int, string> Operator = new Dictionary<int, string>() {{61,"as"}, {62, "await"}, {63, "is"}, {64, "new"}, {65, "sizeof"}, {66, "typeof"}, {67, "true"}, {68, "false"},
            {69, "stackalloc"}, {70, "nameof"}};

        internal readonly Dictionary<int, string> Conversion = new Dictionary<int, string>() { { 71, "explicit" }, { 72, "implicit" }, { 73, "operator" } };
        internal readonly Dictionary<int, string> Access = new Dictionary<int, string>() { { 74, "base" }, { 75, "this" } };
        internal readonly Dictionary<int, string> Literal = new Dictionary<int, string>() { { 76, "null" }, { 77, "default" } };

        internal readonly Dictionary<int, string> Contextual = new Dictionary<int, string>()
        { {78, "add"}, {79, "get"}, {80, "global"}, {81, "partial(Type)"}, {82, "remove"}, {83, "set"},
            {84, "where"}, {85, "value"}, {86, "yield"}};

        internal readonly Dictionary<int, string> Query = new Dictionary<int, string>() { {87, "from clause"}, {88, "where clause"}, {89, "select clause"}, {90, "group clause"},
            {91, "into"}, {92, "orderby clause"}, {93, "join clause"}, {94, "let clause"}, {95, "ascending"}, {96, "descending"}, {97, "on"}, {98,"equals"}, {99,"by"}, {100, "in"}};
      
        internal static Dictionary<int, string> Type = new Dictionary<int, string>()
        {   {0, "The bool keyword is an alias of System.Boolean. It is used to declare variables to store the Boolean values, true and false." },
            {1, "The byte keyword denotes an integral type that stores values as indicated in the following table."},
            {2, "The char keyword is used to declare an instance of the System.Char structure that the .NET Framework uses to represent a Unicode character. The value of a Char object is a 16-bit numeric (ordinal) value."},
            {3, "The decimal keyword indicates a 128-bit data type. Compared to floating-point types, the decimal type has more precision and a smaller range, which makes it appropriate for financial and monetary calculations. The approximate range and precision for the decimal type are shown in the following table."},
            {4, "The double keyword signifies a simple type that stores 64-bit floating-point values. The following table shows the precision and approximate range for the double type."},
            {5, "The enum keyword is used to declare an enumeration, a distinct type that consists of a set of named constants called the enumerator list.\r\nUsually it is best to define an enum directly within a namespace so that all classes in the namespace can access it with equal convenience. However, an enum can also be nested within a class or struct.\r\nBy default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1. For example, in the following enumeration, Sat is 0, Sun is 1, Mon is 2, and so forth."},
            {6, "The float keyword signifies a simple type that stores 32-bit floating-point values. The following table shows the precision and approximate range for the float type."},
            {7, "The int keyword denotes an integral type that stores values according to the size and range shown in the following table."},
            {8, "The long keyword denotes an integral type that stores values according to the size and range shown in the following table."},
            {9, "The sbyte keyword indicates an integral type that stores values according to the size and range shown in the following table."},
            {10, "The short keyword denotes an integral data type that stores values according to the size and range shown in the following table."},
            {11, "A struct type is a value type that is typically used to encapsulate small groups of related variables, such as the coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple struct declaration:\r\npublic struct Book\r\n{\r\n    public decimal price;\r\n    public string title;\r\n    public string author;\r\n}"},
            {12, "The uint keyword signifies an integral type that stores values according to the size."},
            {13, "The ulong keyword denotes an integral type that stores values according to the size"},
            {14, "The ushort keyword indicates an integral data type that stores values according to the size"},
            {15, "Classes are declared using the keyword class, as shown in the following example:\r\nclass TestClass\r\n{\r\n    // Methods, properties, fields, events, delegates \r\n    // and nested classes go here.}\r\n"},
            {16, "The declaration of a delegate type is similar to a method signature. It has a return value and any number of parameters of any type: \r\npublic delegate void TestDelegate(string message); \r\npublic delegate int TestDelegate(MyType m, long num); \r\nA delegate is a reference type that can be used to encapsulate a named or an anonymous method. Delegates are similar to function pointers in C++; however, delegates are type-safe and secure." },
            {17, "The dynamic type enables the operations in which it occurs to bypass compile-time type checking. Instead, these operations are resolved at run time. The dynamic type simplifies access to COM APIs such as the Office Automation APIs, and also to dynamic APIs such as IronPython libraries, and to the HTML Document Object Model (DOM).\r\nType dynamic behaves like type object in most circumstances. However, operations that contain expressions of type dynamic are not resolved or type checked by the compiler. The compiler packages together information about the operation, and that information is later used to evaluate the operation at run time. As part of the process, variables of type dynamic are compiled into variables of type object. Therefore, type dynamic exists only at compile time, not at run time."+
                 "\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        dynamic dyn = 1;\r\n        object obj = 1;\r\n\r\n        // Rest the mouse pointer over dyn and obj to see their\r\n        // types at compile time.\r\n        System.Console.WriteLine(dyn.GetType());\r\n        System.Console.WriteLine(obj.GetType());\r\n    }\r\n}"},
            {18,"An interface contains only the signatures of methods, properties, events or indexers. A class or struct that implements the interface must implement the members of the interface that are specified in the interface definition. In the following example, class ImplementationClass must implement a method named SampleMethod that has no parameters and returns void." },
            {19,"The object type is an alias for Object in the .NET Framework. In the unified type system of C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from Object. You can assign values of any type to variables of type object. When a variable of a value type is converted to object, it is said to be boxed. When a variable of type object is converted to a value type, it is said to be unboxed. " },
            {20,"The string type represents a sequence of zero or more Unicode characters. string is an alias for String in the .NET Framework.\r\nAlthough string is a reference type, the equality operators (== and !=) are defined to compare the values of string objects, not references. This makes testing for string equality more intuitive. For example:"
                +"\r\nstring a = \"hello\";\r\nstring b = \"h\";\r\n// Append to contents of \'b\'\r\nb += \"ello\";\r\nConsole.WriteLine(a == b);\r\nConsole.WriteLine((object)a == (object)b);" },
            {21,"When used as the return type for a method, void specifies that the method doesn\'t return a value.\r\nvoid isn\'t allowed in the parameter list of a method. A method that takes no parameters and returns no value is declared as follows:"
                +"public void SampleMethod()\r\n{\r\n    // Body of the method.\r\n}" },
            {22, "Beginning in Visual C# 3.0, variables that are declared at method scope can have an implicit type var. An implicitly typed local variable is strongly typed just as if you had declared the type yourself, but the compiler determines the type. The following two declarations of i are functionally equivalent:"
                 +"\r\nvar i = 10; // implicitly typed\r\nint i = 10; //explicitly typed" },
            {23,"The abstract modifier indicates that the thing being modified has a missing or incomplete implementation. The abstract modifier can be used with classes, methods, properties, indexers, and events. Use the abstract modifier in a class declaration to indicate that a class is intended only to be a base class of other classes. Members marked as abstract, or included in an abstract class, must be implemented by classes that derive from the abstract class." },
            {24,"Use the async modifier to specify that a method, lambda expression, or anonymous method is asynchronous. If you use this modifier on a method or expression, it\'s referred to as an async method."
                +"\r\npublic async Task<int> ExampleMethodAsync()\r\n{\r\n    // . . . .\r\n}" },
            {25,"You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren\'t variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword. For example: "
                +"\r\nconst int x = 0;\r\npublic const double gravitationalConstant = 6.673e-11;\r\nprivate const string productName = \"Visual C#\";" },
            {26,"The event keyword is used to declare an event in a publisher class."+"The following example shows how to declare and raise an event that uses EventHandler as the underlying delegate type. For the complete code example that also shows how to use the generic EventHandler<TEventArgs> delegate type and how to subscribe to an event and create an event handler method, see How to: Publish Events that Conform to .NET Framework Guidelines (C# Programming Guide)."
                +"\r\npublic class SampleEventArgs\r\n{\r\n    public SampleEventArgs(string s) { Text = s; }\r\n    public String Text {get; private set;} // readonly\r\n}\r\npublic class Publisher\r\n{\r\n    // Declare the delegate (if using non-generic pattern).\r\n    public delegate void SampleEventHandler(object sender, SampleEventArgs e);\r\n\r\n    // Declare the event.\r\n    public event SampleEventHandler SampleEvent;\r\n\r\n    // Wrap the event in a protected virtual method\r\n    // to enable derived classes to raise the event.\r\n    protected virtual void RaiseSampleEvent()\r\n    {\r\n        // Raise the event by using the () operator.\r\n        if (SampleEvent != null)\r\n            SampleEvent(this, new SampleEventArgs(\"Hello\"));\r\n    }\r\n}" },
            {27,"The extern modifier is used to declare a method that is implemented externally. A common use of the extern modifier is with the DllImport attribute when you are using Interop services to call into unmanaged code. In this case, the method must also be declared as static, as shown in the following example:"
                +"[DllImport(\"avifil32.dll\")]\r\nprivate static extern void AVIFileInit();" },
            {28,"For generic type parameters, the in keyword specifies that the type parameter is contravariant. You can use the in keyword in generic interfaces and delegates.\r\nContravariance enables you to use a less derived type than that specified by the generic parameter. This allows for implicit conversion of classes that implement variant interfaces and implicit conversion of delegate types. Covariance and contravariance in generic type parameters are supported for reference types, but they are not supported for value types.\r\nA type can be declared contravariant in a generic interface or delegate if it is used only as a type of method arguments and not used as a method return type. Ref and out parameters cannot be variant.\r\nAn interface that has a contravariant type parameter allows its methods to accept arguments of less derived types than those specified by the interface type parameter. For example, because in .NET Framework 4, in the IComparer<T> interface, type T is contravariant, you can assign an object of the IComparer(Of Person) type to an object of the IComparer(Of Employee) type without using any special conversion methods if Employee inherits Person.\r\nA contravariant delegate can be assigned another delegate of the same type, but with a less derived generic type parameter." },
            {29,"For generic type parameters, the out keyword specifies that the type parameter is covariant. You can use the out keyword in generic interfaces and delegates.\r\nCovariance enables you to use a more derived type than that specified by the generic parameter. This allows for implicit conversion of classes that implement variant interfaces and implicit conversion of delegate types. Covariance and contravariance are supported for reference types, but they are not supported for value types.\r\nAn interface that has a covariant type parameter enables its methods to return more derived types than those specified by the type parameter. For example, because in .NET Framework 4, in IEnumerable<T>, type T is covariant, you can assign an object of the IEnumerabe(Of String) type to an object of the IEnumerable(Of Object) type without using any special conversion methods.\r\nA covariant delegate can be assigned another delegate of the same type, but with a more derived generic type parameter." },
            {30, "The override modifier is required to extend or modify the abstract or virtual implementation of an inherited method, property, indexer, or event."},
            {31,"The readonly keyword is a modifier that you can use on fields. When a field declaration includes a readonly modifier, assignments to the fields introduced by the declaration can only occur as part of the declaration or in a constructor in the same class."
                +"r\nclass Age\r\n{\r\n    readonly int _year;\r\n    Age(int year)\r\n    {\r\n        _year = year;\r\n    }\r\n    void ChangeYear()\r\n    {\r\n        //_year = 1967; // Compile error if uncommented.\r\n    }\r\n}"},
            {32,"When applied to a class, the sealed modifier prevents other classes from inheriting from it. In the following example, class B inherits from class A, but no class can inherit from class B."
                +"class A {}    \r\nsealed class B : A {}" },
            {33, "Use the static modifier to declare a static member, which belongs to the type itself rather than to a specific object. The static modifier can be used with classes, fields, methods, properties, operators, events, and constructors, but it cannot be used with indexers, destructors, or types other than classes. "
                 +"static class CompanyEmployee\r\n{\r\n    public static void DoSomething() { /*...*/// }\r\n    public static void DoSomethingElse() { /*...*/  }\r\n}"},
            {34, "The unsafe keyword denotes an unsafe context, which is required for any operation involving pointers. You can use the unsafe modifier in the declaration of a type or a member. The entire textual extent of the type or member is therefore considered an unsafe context. For example, the following is a method declared with the unsafe modifier:"
                 +"      unsafe static void FastCopy(byte[] src, byte[] dst, int count)\r\n{\r\n    // Unsafe context: can use pointers here.\r\n}"},
            {35, "The virtual keyword is used to modify a method, property, indexer, or event declaration and allow for it to be overridden in a derived class. For example, this method can be overridden by any class that inherits it:"
                 +"\r\npublic virtual double Area() \r\n{\r\n    return x * y;\r\n}"},
            {36, "The volatile keyword indicates that a field might be modified by multiple threads that are executing at the same time. Fields that are declared volatile are not subject to compiler optimizations that assume access by a single thread. This ensures that the most up-to-date value is present in the field at all times.\r\nThe volatile modifier is usually used for a field that is accessed by multiple threads without using the lock statement to serialize access.\r\nThe volatile keyword can be applied to fields of these types:\r\nReference types.\r\nPointer types (in an unsafe context). Note that although the pointer itself can be volatile, the object that it points to cannot. In other words, you cannot declare a \"pointer to volatile.\"\r\nTypes such as sbyte, byte, short, ushort, int, uint, char, float, and bool.\r\nAn enum type with one of the following base types: byte, sbyte, short, ushort, int, or uint.\r\nGeneric type parameters known to be reference types.\r\nIntPtr and UIntPtr.\r\nThe volatile keyword can only be applied to fields of a class or struct. Local variables cannot be declared volatile."},
            {37,"An if statement identifies which statement to run based on the value of a Boolean expression. In the following example, the Boolean variable result is set to true and then checked in the if statement. The output is The condition is true."
                +"\r\nbool condition = true;\r\n\r\nif (condition)\r\n{\r\n    Console.WriteLine(\"The variable is set to true.\");\r\n}\r\nelse\r\n{\r\n    Console.WriteLine(\"The variable is set to false.\");\r\n}" },
            {38,"The switch statement is a control statement that selects a switch section to execute from a list of candidates.\r\nA switch statement includes one or more switch sections. Each switch section contains one or more case labels followed by one or more statements. The following example shows a simple switch statement that has three switch sections. Each switch section has one case label, such as case 1, and two statements."
                +"\r\nint caseSwitch = 1;\r\nswitch (caseSwitch)\r\n{\r\n    case 1:\r\n        Console.WriteLine(\"Case 1\");\r\n        break;\r\n    case 2:\r\n        Console.WriteLine(\"Case 2\");\r\n        break;\r\n    default:\r\n        Console.WriteLine(\"Default case\");\r\n        break;\r\n}" },
            {39,"The do statement executes a statement or a block of statements repeatedly until a specified expression evaluates to false. The body of the loop must be enclosed in braces, {}, unless it consists of a single statement. In that case, the braces are optional."
                +"\r\npublic class TestDoWhile \r\n{\r\n    public static void Main () \r\n    {\r\n        int x = 0;\r\n        do \r\n        {\r\n            Console.WriteLine(x);\r\n            x++;\r\n        } while (x < 5);\r\n    }\r\n}" },
            {40,"By using a for loop, you can run a statement or a block of statements repeatedly until a specified expression evaluates to false. This kind of loop is useful for iterating over arrays and for other applications in which you know in advance how many times you want the loop to iterate."
                +"\r\nclass ForLoopTest \r\n{\r\n    static void Main() \r\n    {\r\n        for (int i = 1; i <= 5; i++)\r\n        {\r\n            Console.WriteLine(i);\r\n        }\r\n    }\r\n}" },
            {41,"The foreach statement repeats a group of embedded statements for each element in an array or an object collection that implements the System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T> interface. The foreach statement is used to iterate through the collection to get the information that you want, but can not be used to add or remove items from the source collection to avoid unpredictable side effects. If you need to add or remove items from the source collection, use a for loop.\r\nThe embedded statements continue to execute for each element in the array or collection. After the iteration has been completed for all the elements in the collection, control is transferred to the next statement following the foreach block.\r\nAt any point within the foreach block, you can break out of the loop by using the break keyword, or step to the next iteration in the loop by using the continue keyword.\r\nA foreach loop can also be exited by the goto, return, or throw statements."
                +"\r\nclass ForEachTest\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        int[] fibarray = new int[] { 0, 1, 1, 2, 3, 5, 8, 13 };\r\n        foreach (int element in fibarray)\r\n        {\r\n            System.Console.WriteLine(element);\r\n        }\r\n        System.Console.WriteLine();\r\n\r\n\r\n        // Compare the previous loop to a similar for loop.\r\n        for (int i = 0; i < fibarray.Length; i++)\r\n        {\r\n            System.Console.WriteLine(fibarray[i]);\r\n        }\r\n        System.Console.WriteLine();\r\n\r\n\r\n        // You can maintain a count of the elements in the collection.\r\n        int count = 0;\r\n        foreach (int element in fibarray)\r\n        {\r\n            count += 1;\r\n            System.Console.WriteLine(\"Element #{0}: {1}\", count, element);\r\n        }\r\n        System.Console.WriteLine(\"Number of elements in the array: {0}\", count);\r\n    }" },
            {42,"The while statement executes a statement or a block of statements until a specified expression evaluates to false." +"\r\nclass WhileTest \r\n{\r\n    static void Main() \r\n    {\r\n        int n = 1;\r\n        while (n < 6) \r\n        {\r\n            Console.WriteLine(\"Current value of n is {0}\", n);\r\n            n++;\r\n        }\r\n    }\r\n}" },
            {43,"The break statement terminates the closest enclosing loop or switch statement in which it appears. Control is passed to the statement that follows the terminated statement, if any"
                +"\r\nclass BreakTest\r\n{\r\n    static void Main()\r\n    {\r\n        for (int i = 1; i <= 100; i++)\r\n        {\r\n            if (i == 5)\r\n            {\r\n                break;\r\n            }\r\n            Console.WriteLine(i);\r\n        }\r\n\r\n        // Keep the console open in debug mode.\r\n        Console.WriteLine(\"Press any key to exit.\");\r\n        Console.ReadKey();\r\n    }\r\n}" },
            {44,"The continue statement passes control to the next iteration of the enclosing while, do, for, or foreach statement in which it appears."
                +"\r\nclass ContinueTest\r\n{\r\n    static void Main()\r\n    {\r\n        for (int i = 1; i <= 10; i++)\r\n        {\r\n            if (i < 9)\r\n            {\r\n                continue;\r\n            }\r\n            Console.WriteLine(i);\r\n        }\r\n\r\n        // Keep the console open in debug mode.\r\n        Console.WriteLine(\"Press any key to exit.\");\r\n        Console.ReadKey();\r\n    }\r\n}" },
            {45,"The goto statement transfers the program control directly to a labeled statement.\r\nA common use of goto is to transfer control to a specific switch-case label or the default label in a switch statement.\r\nThe goto statement is also useful to get out of deeply nested loops."
                +"\r\nclass SwitchTest\r\n{\r\n    static void Main()\r\n    {\r\n        Console.WriteLine(\"Coffee sizes: 1=Small 2=Medium 3=Large\");\r\n        Console.Write(\"Please enter your selection: \");\r\n        string s = Console.ReadLine();\r\n        int n = int.Parse(s);\r\n        int cost = 0;\r\n        switch (n)\r\n        {\r\n            case 1:\r\n                cost += 25;\r\n                break;\r\n            case 2:\r\n                cost += 25;\r\n                goto case 1;\r\n            case 3:\r\n                cost += 50;\r\n                goto case 1;\r\n            default:\r\n                Console.WriteLine(\"Invalid selection.\");\r\n                break;\r\n        }\r\n        if (cost != 0)\r\n        {\r\n            Console.WriteLine(\"Please insert {0} cents.\", cost);\r\n        }\r\n        Console.WriteLine(\"Thank you for your business.\");\r\n\r\n        // Keep the console open in debug mode.\r\n        Console.WriteLine(\"Press any key to exit.\");\r\n        Console.ReadKey();\r\n    }\r\n}" },
            {46,"The return statement terminates execution of the method in which it appears and returns control to the calling method. It can also return an optional value. If the method is a void type, the return statement can be omitted.\r\nIf the return statement is inside a try block, the finally block, if one exists, will be executed before control returns to the calling method."
                +"\r\nclass ReturnTest\r\n{\r\n    static double CalculateArea(int r)\r\n    {\r\n        double area = r * r * Math.PI;\r\n        return area;\r\n    }\r\n\r\n    static void Main()\r\n    {\r\n        int radius = 5;\r\n        double result = CalculateArea(radius);\r\n        Console.WriteLine(\"The area is {0:0.00}\", result);\r\n\r\n        // Keep the console open in debug mode.\r\n        Console.WriteLine(\"Press any key to exit.\");\r\n        Console.ReadKey();\r\n    }\r\n}"},
            {47,"The throw statement is used to signal the occurrence of an anomalous situation (exception) during the program execution."
                +"\r\npublic class ThrowTest2\r\n{\r\n\r\n    static int GetNumber(int index)\r\n    {\r\n        int[] nums = { 300, 600, 900 };\r\n        if (index > nums.Length)\r\n        {\r\n            throw new IndexOutOfRangeException();\r\n        }\r\n        return nums[index];\r\n\r\n    }\r\n    static void Main() \r\n    {\r\n        int result = GetNumber(3);\r\n\r\n    }\r\n}" },
            {48,"The try-catch statement consists of a try block followed by one or more catch clauses, which specify handlers for different exceptions. When an exception is thrown, the common language runtime (CLR) looks for the catch statement that handles this exception. If the currently executing method does not contain such a catch block, the CLR looks at the method that called the current method, and so on up the call stack. If no catch block is found, then the CLR displays an unhandled exception message to the user and stops execution of the program.\r\nThe try block contains the guarded code that may cause the exception. The block is executed until an exception is thrown or it is completed successfully. For example, the following attempt to cast a null object raises the NullReferenceException exception:"
                +"\r\nobject o2 = null;\r\ntry\r\n{\r\n    int i2 = (int)o2;   // Error\r\n}" },
            {49,"By using a finally block, you can clean up any resources that are allocated in a try block, and you can run code even if an exception occurs in the try block. Typically, the statements of a finally block run when control leaves a try statement. The transfer of control can occur as a result of normal execution, of execution of a break, continue, goto, or return statement, or of propagation of an exception out of the try statement.\r\nWithin a handled exception, the associated finally block is guaranteed to be run. However, if the exception is unhandled, execution of the finally block is dependent on how the exception unwind operation is triggered. That, in turn, is dependent on how your computer is set up."
                +"Usually, when an unhandled exception ends an application, whether or not the finally block is run is not important. However, if you have statements in a finally block that must be run even in that situation, one solution is to add a catch block to the try-finally statement. Alternatively, you can catch the exception that might be thrown in the try block of a try-finally statement higher up the call stack. That is, you can catch the exception in the method that calls the method that contains the try-finally statement, or in the method that calls that method, or in any method in the call stack. If the exception is not caught, execution of the finally block depends on whether the operating system chooses to trigger an exception unwind operation."
                +"\r\npublic class ThrowTestA\r\n{\r\n    static void Main()\r\n    {\r\n        int i = 123;\r\n        string s = \"Some string\";\r\n        object obj = s;\r\n\r\n        try\r\n        {\r\n            // Invalid conversion; obj contains a string, not a numeric type.\r\n            i = (int)obj;\r\n\r\n            // The following statement is not run.\r\n            Console.WriteLine(\"WriteLine at the end of the try block.\");\r\n        }\r\n        finally\r\n        {\r\n            // To run the program in Visual Studio, type CTRL+F5. Then \r\n            // click Cancel in the error dialog.\r\n            Console.WriteLine(\"\\nExecution of the finally block after an unhandled\\n\" +\r\n                \"error depends on how the exception unwind operation is triggered.\");\r\n            Console.WriteLine(\"i = {0}\", i);\r\n        }\r\n    }" },
            {50,"A common usage of catch and finally together is to obtain and use resources in a try block, deal with exceptional circumstances in a catch block, and release the resources in the finally block."
                +"\r\npublic class EHClass\r\n{\r\n    void ReadFile(int index)\r\n    {\r\n        // To run this code, substitute a valid path from your local machine\r\n        string path = @\"c:\\users\\public\\test.txt\";\r\n        System.IO.StreamReader file = new System.IO.StreamReader(path);\r\n        char[] buffer = new char[10];\r\n        try\r\n        {\r\n            file.ReadBlock(buffer, index, buffer.Length);\r\n        }\r\n        catch (System.IO.IOException e)\r\n        {\r\n            Console.WriteLine(\"Error reading from {0}. Message = {1}\", path, e.Message);\r\n        }\r\n\r\n        finally\r\n        {\r\n            if (file != null)\r\n            {\r\n                file.Close();\r\n            }\r\n        }\r\n        // Do something with buffer...\r\n    }\r\n\r\n}" },
            {51,"The checked keyword is used to explicitly enable overflow checking for integral-type arithmetic operations and conversions.\r\nBy default, an expression that contains only constant values causes a compiler error if the expression produces a value that is outside the range of the destination type. If the expression contains one or more non-constant values, the compiler does not detect the overflow. Evaluating the expression assigned to i2 in the following example does not cause a compiler error."
                +" \r\nThe following example causes compiler error CS0220 because 2147483647\r\n is the maximum value for integers. \r\nint i1 = 2147483647 + 10;\r\n\r\n The following example, which includes variable ten, does not cause\r\n// a compiler error.\r\nint ten = 10;\r\nint i2 = 2147483647 + ten;\r\n\r\n// By default, the overflow in the previous statement also does\r\n// not cause a run-time exception. The following line displays \r\n// -2,147,483,639 as the sum of 2,147,483,647 and 10.\r\nConsole.WriteLine(i2);" },
            {52,"The unchecked keyword is used to suppress overflow-checking for integral-type arithmetic operations and conversions.\r\nIn an unchecked context, if an expression produces a value that is outside the range of the destination type, the overflow is not flagged. For example, because the calculation in the following example is performed in an unchecked block or expression, the fact that the result is too large for an integer is ignored, and int1 is assigned the value -2,147,483,639."
                +"\r\nunchecked\r\n{\r\n    int1 = 2147483647 + 10;\r\n}\r\nint1 = unchecked(ConstantMax + 10);" },
            {53,"The fixed statement prevents the garbage collector from relocating a movable variable. The fixed statement is only permitted in an unsafe context. Fixed can also be used to create fixed size buffers.\r\nThe fixed statement sets a pointer to a managed variable and \"pins\" that variable during the execution of the statement. Without fixed, pointers to movable managed variables would be of little use since garbage collection could relocate the variables unpredictably. The C# compiler only lets you assign a pointer to a managed variable in a fixed statement."
                +"\r\nunsafe static void TestMethod()\r\n{\r\n\r\n    // Assume that the following class exists.\r\n    //class Point \r\n    //{ \r\n    //    public int x;\r\n    //    public int y; \r\n    //}\r\n\r\n    // Variable pt is a managed variable, subject to garbage collection.\r\n    Point pt = new Point();\r\n\r\n    // Using fixed allows the address of pt members to be taken,\r\n    // and \"pins\" pt so that it is not relocated.\r\n\r\n    fixed (int* p = &pt.x)\r\n    {\r\n        *p = 1;\r\n    }        \r\n\r\n}"},
            {54,"The lock keyword marks a statement block as a critical section by obtaining the mutual-exclusion lock for a given object, executing a statement, and then releasing the lock. The following example includes a lock statement."
                +"\r\nclass Account\r\n{\r\n    decimal balance;\r\n    private Object thisLock = new Object();\r\n\r\n    public void Withdraw(decimal amount)\r\n    {\r\n        lock (thisLock)\r\n        {\r\n            if (amount > balance)\r\n            {\r\n                throw new Exception(\"Insufficient funds\");\r\n            }\r\n            balance -= amount;\r\n        }\r\n    }\r\n}" },
            {55,"By using the params keyword, you can specify a method parameter that takes a variable number of arguments.\r\nYou can send a comma-separated list of arguments of the type specified in the parameter declaration or an array of arguments of the specified type. You also can send no arguments. If you send no arguments, the length of the params list is zero.\r\nNo additional parameters are permitted after the params keyword in a method declaration, and only one params keyword is permitted in a method declaration."
                +"\r\npublic class MyClass\r\n{\r\n    public static void UseParams(params int[] list)\r\n    {\r\n        for (int i = 0; i < list.Length; i++)\r\n        {\r\n            Console.Write(list[i] + \" \");\r\n        }\r\n        Console.WriteLine();\r\n    }\r\n\r\n    public static void UseParams2(params object[] list)\r\n    {\r\n        for (int i = 0; i < list.Length; i++)\r\n        {\r\n            Console.Write(list[i] + \" \");\r\n        }\r\n        Console.WriteLine();\r\n    }\r\n\r\n    static void Main()\r\n    {\r\n        // You can send a comma-separated list of arguments of the \r\n        // specified type.\r\n        UseParams(1, 2, 3, 4);\r\n        UseParams2(1, \'a\', \"test\");\r\n\r\n        // A params parameter accepts zero or more arguments.\r\n        // The following calling statement displays only a blank line.\r\n        UseParams2();\r\n\r\n        // An array argument can be passed, as long as the array\r\n        // type matches the parameter type of the method being called.\r\n        int[] myIntArray = { 5, 6, 7, 8, 9 };\r\n        UseParams(myIntArray);\r\n\r\n        object[] myObjArray = { 2, \'b\', \"test\", \"again\" };\r\n        UseParams2(myObjArray);\r\n\r\n        // The following call causes a compiler error because the object\r\n        // array cannot be converted into an integer array.\r\n        //UseParams(myObjArray);\r\n\r\n        // The following call does not cause an error, but the entire \r\n        // integer array becomes the first element of the params array.\r\n        UseParams2(myIntArray);\r\n    }\r\n}" },
            {56,"The ref keyword causes an argument to be passed by reference, not by value. The effect of passing by reference is that any change to the parameter in the called method is reflected in the calling method. For example, if the caller passes a local variable expression or an array element access expression, and the called method replaces the object to which the ref parameter refers, then the caller’s local variable or the array element now refer to the new object."
                +"\r\nclass RefExample\r\n{\r\n    static void Method(ref int i)\r\n    {\r\n        // Rest the mouse pointer over i to verify that it is an int.\r\n        // The following statement would cause a compiler error if i\r\n        // were boxed as an object.\r\n        i = i + 44;\r\n    }\r\n\r\n    static void Main()\r\n    {\r\n        int val = 1;\r\n        Method(ref val);\r\n        Console.WriteLine(val);\r\n\r\n        // Output: 45\r\n    }\r\n}" },
            {57,"You can use the out contextual keyword in two contexts (each is a link to detailed information), as a parameter modifier or in generic type parameter declarations in interfaces and delegates. This topic discusses the parameter modifier, but you can see this other topic for information on the generic type parameter declarations.\r\nThe out keyword causes arguments to be passed by reference. This is like the ref keyword, except that ref requires that the variable be initialized before it is passed. To use an out parameter, both the method definition and the calling method must explicitly use the out keyword. For example:"
                +"\r\nclass OutExample\r\n{\r\n    static void Method(out int i)\r\n    {\r\n        i = 44;\r\n    }\r\n    static void Main()\r\n    {\r\n        int value;\r\n        Method(out value);\r\n        // value is now 44\r\n    }\r\n}"
                +"The out keyword causes arguments to be passed by reference. This is like the ref keyword, except that ref requires that the variable be initialized before it is passed. To use an out parameter, both the method definition and the calling method must explicitly use the out keyword. For example:"
                +"\r\nclass OutExample\r\n{\r\n    static void Method(out int i)\r\n    {\r\n        i = 44;\r\n    }\r\n    static void Main()\r\n    {\r\n        int value;\r\n        Method(out value);\r\n        // value is now 44\r\n    }\r\n}" },
            {58,"The namespace keyword is used to declare a scope that contains a set of related objects. You can use a namespace to organize code elements and to create globally unique types."
                +"\r\nnamespace SampleNamespace\r\n{\r\n    class SampleClass { }\r\n\r\n    interface SampleInterface { }\r\n\r\n    struct SampleStruct { }\r\n\r\n    enum SampleEnum { a, b }\r\n\r\n    delegate void SampleDelegate(int i);\r\n\r\n    namespace SampleNamespace.Nested\r\n    {\r\n        class SampleClass2 { }\r\n    }\r\n}" },
            {59,"The using directive has three uses: \r\nTo allow the use of types in a namespace so that you do not have to qualify the use of a type in that namespace: \r\nusing System.Text;"
                +"\r\nTo allow you to access static members of a type without having to qualify the access with the type name: \r\nusing static System.Math;"
                +"\r\nTo create an alias for a namespace or a type. This is called a using alias directive. \r\nusing Project = PC.MyCompany.Project;" +
                "\r\nYou can access static members of a type without having to qualify the access with the type name:" +
                "\r\nusing static System.Console; \r\nusing static System.Math;\r\nclass Program \r\n{ \r\n    static void Main() \r\n    { \r\n        WriteLine(Sqrt(3*3 + 4*4)); \r\n    } \r\n}"},
            {60,"Provides a convenient syntax that ensures the correct use of IDisposable objects." +
                "\r\nusing (Font font1 = new Font(\"Arial\", 10.0f)) \r\n{\r\n    byte charset = font1.GdiCharSet;\r\n}" },
            {61,"You can use the as operator to perform certain types of conversions between compatible reference types or nullable types. The following code shows an example." +
                "\r\nclass csrefKeywordsOperators\r\n{\r\n    class Base\r\n    {\r\n        public override string  ToString()\r\n        {\r\n           return \"Base\";\r\n        }\r\n    }\r\n    class Derived : Base \r\n    { }\r\n\r\n    class Program\r\n    {\r\n        static void Main()\r\n        {\r\n\r\n            Derived d = new Derived();\r\n\r\n            Base b = d as Base;\r\n            if (b != null)\r\n            {\r\n                Console.WriteLine(b.ToString());\r\n            }\r\n\r\n        }\r\n    }\r\n}" },
            {62,"The await operator is applied to a task in an asynchronous method to suspend the execution of the method until the awaited task completes. The task represents ongoing work.\r\nThe asynchronous method in which await is used must be modified by the async keyword. Such a method, defined by using the async modifier, and usually containing one or more await expressions, is referred to as an async method." +
                "\r\nprivate async Task SumPageSizesAsync()\r\n{\r\n    // To use the HttpClient type in desktop apps, you must include a using directive and add a \r\n    // reference for the System.Net.Http namespace.\r\n    HttpClient client = new HttpClient();\r\n    // . . .\r\n    Task<byte[]> getContentsTask = client.GetByteArrayAsync(url);\r\n    byte[] urlContents = await getContentsTask;\r\n\r\n    // Equivalently, now that you see how it works, you can write the same thing in a single line.\r\n    //byte[] urlContents = await client.GetByteArrayAsync(url);\r\n    // . . .\r\n}" },
            {63,"Checks if an object is compatible with a given type. For example, the following code can determine if an object is an instance of the MyObject type, or a type that derives from MyObject:" +
                "\r\nif (obj is MyObject)\r\n{\r\n}" },
            {64,"In C#, the new keyword can be used as an operator, a modifier, or a constraint." },
            {65,"Used to obtain the size in bytes for an unmanaged type. Unmanaged types include the built-in types that are listed in the table that follows, and also the following:" +
                "\r\nEnum types\r\nPointer types\r\nUser-defined structs that do not contain any fields or properties that are reference types" +
                "// \r\nConstant value 4:\r\nint intSize = sizeof(int); " },
            {66,"Used to obtain the System.Type object for a type. A typeof expression takes the following form: System.Type type = typeof(int);" },
            {67,"Used as an overloaded operator or as a literal" },
            {68,"Used as an overloaded operator or as a literal" },
            {69,"The stackalloc keyword is used in an unsafe code context to allocate a block of memory on the stack. " +
                "\r\nclass Test\r\n{\r\n    static unsafe void Main()\r\n    {\r\n        const int arraySize = 20;\r\n        int* fib = stackalloc int[arraySize];\r\n        int* p = fib;\r\n        // The sequence begins with 1, 1.\r\n        *p++ = *p++ = 1;\r\n        for (int i = 2; i < arraySize; ++i, ++p)\r\n        {\r\n            // Sum the previous two numbers.\r\n            *p = p[-1] + p[-2];\r\n        }\r\n        for (int i = 0; i < arraySize; ++i)\r\n        {\r\n            Console.WriteLine(fib[i]);\r\n        }\r\n\r\n        // Keep the console window open in debug mode.\r\n        System.Console.WriteLine(\"Press any key to exit.\");\r\n        System.Console.ReadKey();\r\n    }\r\n}" },
            {70,"Used to obtain the simple (unqualified) string name of a variable, type, or member. When reporting errors in code, hooking up model-view-controller (MVC) links, firing property changed events, etc., you often want to capture the string name of a method. Using nameof helps keep your code valid when renaming definitions. Before you had to use string literals to refer to definitions, which is brittle when renaming code elements because tools do not know to check these string literals." +
                "\r\nif (x == null) throw new ArgumentNullException(nameof(x));\r\nWriteLine(nameof(person.Address.ZipCode)); // prints \"ZipCode”" },
            {71,"The explicit keyword declares a user-defined type conversion operator that must be invoked with a cast. For example, this operator converts from a class called Fahrenheit to a class called Celsius:" +
                "// \r\nMust be defined inside a class called Fahrenheit:\r\npublic static explicit operator Celsius(Fahrenheit fahr)\r\n{\r\n    return new Celsius((5.0f / 9.0f) * (fahr.degrees - 32));\r\n}" },
            {72,"The implicit keyword is used to declare an implicit user-defined type conversion operator. Use it to enable implicit conversions between a user-defined type and another type, if the conversion is guaranteed not to cause a loss of data" +
                "\r\nclass Digit\r\n{\r\n    public Digit(double d) { val = d; }\r\n    public double val;\r\n    // ...other members\r\n\r\n    // User-defined conversion from Digit to double\r\n    public static implicit operator double(Digit d)\r\n    {\r\n        return d.val;\r\n    }\r\n    //  User-defined conversion from double to Digit\r\n    public static implicit operator Digit(double d)\r\n    {\r\n        return new Digit(d);\r\n    }\r\n}\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Digit dig = new Digit(7);\r\n        //This call invokes the implicit \"double\" operator\r\n        double num = dig;\r\n        //This call invokes the implicit \"Digit\" operator\r\n        Digit dig2 = 12;\r\n        Console.WriteLine(\"num = {0} dig2 = {1}\", num, dig2.val);\r\n        Console.ReadLine();\r\n    }\r\n}" },
            {73,"Use the operator keyword to overload a built-in operator or to provide a user-defined conversion in a class or struct declaration." +
                "\r\nclass Fraction\r\n{\r\n    int num, den;\r\n    public Fraction(int num, int den)\r\n    {\r\n        this.num = num;\r\n        this.den = den;\r\n    }\r\n\r\n    // overload operator +\r\n    public static Fraction operator +(Fraction a, Fraction b)\r\n    {\r\n        return new Fraction(a.num * b.den + b.num * a.den,\r\n           a.den * b.den);\r\n    }\r\n\r\n    // overload operator *\r\n    public static Fraction operator *(Fraction a, Fraction b)\r\n    {\r\n        return new Fraction(a.num * b.num, a.den * b.den);\r\n    }\r\n\r\n    // user-defined conversion from Fraction to double\r\n    public static implicit operator double(Fraction f)\r\n    {\r\n        return (double)f.num / f.den;\r\n    }\r\n}\r\n\r\nclass Test\r\n{\r\n    static void Main()\r\n    {\r\n        Fraction a = new Fraction(1, 2);\r\n        Fraction b = new Fraction(3, 7);\r\n        Fraction c = new Fraction(2, 3);\r\n        Console.WriteLine((double)(a * b + c));\r\n    }\r\n}" },
            {74,"The base keyword is used to access members of the base class from within a derived class:\r\nCall a method on the base class that has been overridden by another method.\r\nSpecify which base-class constructor should be called when creating instances of the derived class.\r\nA base class access is permitted only in a constructor, an instance method, or an instance property accessor.\r\nIt is an error to use the base keyword from within a static method.\r\nThe base class that is accessed is the base class specified in the class declaration. For example, if you specify class ClassB : ClassA, the members of ClassA are accessed from ClassB, regardless of the base class of ClassA." +
                "\r\npublic class Person\r\n{\r\n    protected string ssn = \"444-55-6666\";\r\n    protected string name = \"John L. Malgraine\";\r\n\r\n    public virtual void GetInfo()\r\n    {\r\n        Console.WriteLine(\"Name: {0}\", name);\r\n        Console.WriteLine(\"SSN: {0}\", ssn);\r\n    }\r\n}\r\nclass Employee : Person\r\n{\r\n    public string id = \"ABC567EFG\";\r\n    public override void GetInfo()\r\n    {\r\n        // Calling the base class GetInfo method:\r\n        base.GetInfo();\r\n        Console.WriteLine(\"Employee ID: {0}\", id);\r\n    }\r\n}\r\n\r\nclass TestClass\r\n{\r\n    static void Main()\r\n    {\r\n        Employee E = new Employee();\r\n        E.GetInfo();\r\n    }\r\n}" },
            {75,"The this keyword refers to the current instance of the class and is also used as a modifier of the first parameter of an extension method." +
                "\r\npublic Employee(string name, string alias)\r\n{\r\n    // Use this to qualify the fields, name and alias:\r\n    this.name = name;\r\n    this.alias = alias;\r\n}" },
            {76,"The null keyword is a literal that represents a null reference, one that does not refer to any object. null is the default value of reference-type variables. Ordinary value types cannot be null. However, C# 2.0 introduced nullable value types. See Nullable Types (C# Programming Guide)." },
            {77,"The default keyword can be used in the switch statement or in generic code" },
            {78,"The add contextual keyword is used to define a custom event accessor that is invoked when client code subscribes to your event. If you supply a custom add accessor, you must also supply a remove accessor." +
                "\r\nclass Events : IDrawingObject\r\n{\r\n    event EventHandler PreDrawEvent;\r\n\r\n    event EventHandler IDrawingObject.OnDraw\r\n    {\r\n        add\r\n        {\r\n            lock (PreDrawEvent)\r\n            {\r\n                PreDrawEvent += value;\r\n            }\r\n        }\r\n        remove\r\n        {\r\n            lock (PreDrawEvent)\r\n            {\r\n                PreDrawEvent -= value;\r\n            }\r\n        }\r\n    }\r\n\r\n}" },
            {79,"The get keyword defines an accessor method in a property or indexer that retrieves the value of the property or the indexer element. " +
                "\r\nclass TimePeriod\r\n{\r\n    private double _seconds;\r\n    public double Seconds\r\n    {\r\n        get { return _seconds; }\r\n        set { _seconds = value; }\r\n    }\r\n\r\n\r\n}" },
            {80,"The global contextual keyword, when it comes before the :: operator, refers to the global namespace, which is the default namespace for any C# program and is otherwise unnamed. For more information, see How to: Use the Global Namespace Alias (C# Programming Guide)." +
                "\r\nclass TestClass : global::TestApp { }" },
            {81,"Partial type definitions allow for the definition of a class, struct, or interface to be split into multiple files." +
                "\r\nnamespace PC\r\n{\r\n    partial class A\r\n    {\r\n        int num = 0;\r\n        void MethodA() { }\r\n        partial void MethodC();\r\n    }\r\n}" +
                "\r\nIn File2.cs the declaration: \r\nnamespace PC\r\n{\r\n    partial class A\r\n    {\r\n        void MethodB() { }\r\n        partial void MethodC() { }\r\n    }\r\n}" },
            {82,"The remove contextual keyword is used to define a custom event accessor that is invoked when client code unsubscribes from your event. If you supply a custom remove accessor, you must also supply an add accessor." +
                "\r\nclass Events : IDrawingObject\r\n{\r\n    event EventHandler PreDrawEvent;\r\n\r\n    event EventHandler IDrawingObject.OnDraw\r\n    {\r\n        add\r\n        {\r\n            lock (PreDrawEvent)\r\n            {\r\n                PreDrawEvent += value;\r\n            }\r\n        }\r\n        remove\r\n        {\r\n            lock (PreDrawEvent)\r\n            {\r\n                PreDrawEvent -= value;\r\n            }\r\n        }\r\n    }\r\n\r\n}" },
            {83,"The set keyword defines an accessor method in a property or indexer that assigns the value of the property or the indexer element." +
                "\r\nclass TimePeriod\r\n{\r\n    private double _seconds;\r\n    public double Seconds\r\n    {\r\n        get { return _seconds; }\r\n        set { _seconds = value; }\r\n    }\r\n\r\n\r\n}"},
            {84,"In a generic type definition, the where clause is used to specify constraints on the types that can be used as arguments for a type parameter defined in a generic declaration. For example, you can declare a generic class, MyGenericClass, such that the type parameter T implements the IComparable<T> interface:" +
                "\r\npublic class MyGenericClass<T> where T:IComparable { } \r\nclass MyClass<T, U>\r\n    where T : class\r\n    where U : struct\r\n{ }" },
            {85,"The contextual keyword value is used in the set accessor in ordinary property declarations. It is similar to an input parameter on a method. The word value references the value that client code is attempting to assign to the property. In the following example, MyDerivedClass has a property called Name that uses the value parameter to assign a new string to the backing field name. From the point of view of client code, the operation is written as a simple assignment." +
                "\r\nclass MyBaseClass\r\n{\r\n    // virtual auto-implemented property. Overrides can only\r\n    // provide specialized behavior if they implement get and set accessors.\r\n    public virtual string Name { get; set; }\r\n\r\n    // ordinary virtual property with backing field\r\n    private int num;\r\n    public virtual int Number\r\n    {\r\n        get { return num; }\r\n        set { num = value; }\r\n    }\r\n}\r\n\r\n\r\nclass MyDerivedClass : MyBaseClass\r\n{\r\n    private string name;\r\n\r\n   // Override auto-implemented property with ordinary property\r\n   // to provide specialized accessor behavior.\r\n    public override string Name\r\n    {\r\n        get\r\n        {\r\n            return name;\r\n        }\r\n        set\r\n        {\r\n            if (value != String.Empty)\r\n            {\r\n                name = value;\r\n            }\r\n            else\r\n            {\r\n                name = \"Unknown\";\r\n            }\r\n        }\r\n    }\r\n\r\n}" },
            {86,"When you use the yield keyword in a statement, you indicate that the method, operator, or get accessor in which it appears is an iterator. Using yield to define an iterator removes the need for an explicit extra class (the class that holds the state for an enumeration, see IEnumerator<T> for an example) when you implement the IEnumerable and IEnumerator pattern for a custom collection type." +
                "\r\npublic class PowersOf2\r\n{\r\n    static void Main()\r\n    {\r\n        // Display powers of 2 up to the exponent of 8:\r\n        foreach (int i in Power(2, 8))\r\n        {\r\n            Console.Write(\"{0} \", i);\r\n        }\r\n    }\r\n\r\n    public static System.Collections.Generic.IEnumerable<int> Power(int number, int exponent)\r\n    {\r\n        int result = 1;\r\n\r\n        for (int i = 0; i < exponent; i++)\r\n        {\r\n            result = result * number;\r\n            yield return result;\r\n        }\r\n    }\r\n\r\n    // Output: 2 4 8 16 32 64 128 256\r\n}" },
            {87,"A query expression must begin with a from clause. Additionally, a query expression can contain sub-queries, which also begin with a from clause. The from clause specifies the following:\r\nThe data source on which the query or sub-query will be run.\r\nA local range variable that represents each element in the source sequence.\r\nBoth the range variable and the data source are strongly typed. The data source referenced in the from clause must have a type of IEnumerable, IEnumerable<T>, or a derived type such as IQueryable<T>.\r\nIn the following example, numbers is the data source and num is the range variable. Note that both variables are strongly typed even through the var keyword is used." +
                "\r\nclass LowNums\r\n{\r\n    static void Main()\r\n    {   \r\n        // A simple data source.\r\n        int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\n\r\n        // Create the query.\r\n        // lowNums is an IEnumerable<int>\r\n        var lowNums = from num in numbers\r\n            where num < 5\r\n            select num;\r\n\r\n        // Execute the query.\r\n        foreach (int i in lowNums)\r\n        {\r\n            Console.Write(i + \" \");\r\n        }\r\n    }        \r\n}" },
            {88,"The where clause is used in a query expression to specify which elements from the data source will be returned in the query expression. It applies a Boolean condition (predicate) to each source element (referenced by the range variable) and returns those for which the specified condition is true. A single query expression may contain multiple where clauses and a single clause may contain multiple predicate subexpressions." +
                "\r\nclass WhereSample\r\n{\r\n    static void Main()\r\n    {   \r\n        // Simple data source. Arrays support IEnumerable<T>.\r\n        int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\n\r\n        // Simple query with one predicate in where clause.\r\n        var queryLowNums =\r\n            from num in numbers\r\n            where num < 5\r\n            select num;\r\n\r\n        // Execute the query.\r\n        foreach (var s in queryLowNums)\r\n        {\r\n            Console.Write(s.ToString() + \" \");\r\n        }\r\n    }\r\n}" },
            {89,"In a query expression, the select clause specifies the type of values that will be produced when the query is executed. The result is based on the evaluation of all the previous clauses and on any expressions in the select clause itself. A query expression must terminate with either a select clause or a group clause." +
                "\r\nclass SelectSample1\r\n{   \r\n    static void Main()\r\n    {           \r\n        //Create the data source\r\n        List<int> Scores = new List<int>() { 97, 92, 81, 60 };\r\n\r\n        // Create the query.\r\n        IEnumerable<int> queryHighScores =\r\n            from score in Scores\r\n            where score > 80\r\n            select score;\r\n\r\n        // Execute the query.\r\n        foreach (int i in queryHighScores)\r\n        {\r\n            Console.Write(i + \" \");\r\n        }            \r\n    }\r\n}" },
            {90,"The group clause returns a sequence of IGrouping<TKey, TElement> objects that contain zero or more items that match the key value for the group. For example, you can group a sequence of strings according to the first letter in each string. In this case, the first letter is the key and has a type char, and is stored in the Key property of each IGrouping<TKey, TElement> object. The compiler infers the type of the key." +
                "// \r\nQuery variable is an IEnumerable<IGrouping<char, Student>>\r\nvar studentQuery1 =\r\n    from student in students\r\n    group student by student.Last[0];" },
            {91,"The into contextual keyword can be used to create a temporary identifier to store the results of a group, join or select clause into a new identifier. This identifier can itself be a generator for additional query commands. When used in a group or select clause, the use of the new identifier is sometimes referred to as a continuation." +
                "\r\nclass IntoSample1\r\n{\r\n    static void Main()\r\n    {\r\n\r\n        // Create a data source.\r\n        string[] words = { \"apples\", \"blueberries\", \"oranges\", \"bananas\", \"apricots\"};\r\n\r\n        // Create the query.\r\n        var wordGroups1 =\r\n            from w in words\r\n            group w by w[0] into fruitGroup\r\n            where fruitGroup.Count() >= 2\r\n            select new { FirstLetter = fruitGroup.Key, Words = fruitGroup.Count() };\r\n\r\n        // Execute the query. Note that we only iterate over the groups, \r\n        // not the items in each group\r\n        foreach (var item in wordGroups1)\r\n        {\r\n            Console.WriteLine(\" {0} has {1} elements.\", item.FirstLetter, item.Words);\r\n        }\r\n\r\n        // Keep the console window open in debug mode\r\n        Console.WriteLine(\"Press any key to exit.\");\r\n        Console.ReadKey();\r\n    }\r\n}" },
            {92,"In a query expression, the orderby clause causes the returned sequence or subsequence (group) to be sorted in either ascending or descending order. Multiple keys can be specified in order to perform one or more secondary sort operations. The sorting is performed by the default comparer for the type of the element. The default sort order is ascending. You can also specify a custom comparer. However, it is only available by using method-based syntax. For more information, see Sorting Data." +
                "\r\nclass OrderbySample1\r\n{\r\n    static void Main()\r\n    {            \r\n        // Create a delicious data source.\r\n        string[] fruits = { \"cherry\", \"apple\", \"blueberry\" };\r\n\r\n        // Query for ascending sort.\r\n        IEnumerable<string> sortAscendingQuery =\r\n            from fruit in fruits\r\n            orderby fruit //\"ascending\" is default\r\n            select fruit;\r\n\r\n        // Query for descending sort.\r\n        IEnumerable<string> sortDescendingQuery =\r\n            from w in fruits\r\n            orderby w descending\r\n            select w;            \r\n\r\n        // Execute the query.\r\n        Console.WriteLine(\"Ascending:\");\r\n        foreach (string s in sortAscendingQuery)\r\n        {\r\n            Console.WriteLine(s);\r\n        }\r\n\r\n        // Execute the query.\r\n        Console.WriteLine(Environment.NewLine + \"Descending:\");\r\n        foreach (string s in sortDescendingQuery)\r\n        {\r\n            Console.WriteLine(s);\r\n        }\r\n\r\n        // Keep the console window open in debug mode.\r\n        Console.WriteLine(\"Press any key to exit.\");\r\n        Console.ReadKey();\r\n    }\r\n}" },
            {93,"The join clause is useful for associating elements from different source sequences that have no direct relationship in the object model. The only requirement is that the elements in each source share some value that can be compared for equality. For example, a food distributor might have a list of suppliers of a certain product, and a list of buyers. A join clause can be used, for example, to create a list of the suppliers and buyers of that product who are all in the same specified region.\r\nA join clause takes two source sequences as input. The elements in each sequence must either be or contain a property that can be compared to a corresponding property in the other sequence. The join clause compares the specified keys for equality by using the special equals keyword. All joins performed by the join clause are equijoins. The shape of the output of a join clause depends on the specific type of join you are performing. The following are three most common join types:\r\nInner join\r\nGroup join\r\nLeft outer join" +
                "\r\n var innerJoinQuery =\r\n    from category in categories\r\n    join prod in products on category.ID equals prod.CategoryID\r\n    select new { ProductName = prod.Name, Category = category.Name }; //produces flat sequence" },
            {94,"In a query expression, it is sometimes useful to store the result of a sub-expression in order to use it in subsequent clauses. You can do this with the let keyword, which creates a new range variable and initializes it with the result of the expression you supply. Once initialized with a value, the range variable cannot be used to store another value. However, if the range variable holds a queryable type, it can be queried." +
                "\r\nclass LetSample1\r\n{\r\n    static void Main()\r\n    {\r\n        string[] strings = \r\n        {\r\n            \"A penny saved is a penny earned.\",\r\n            \"The early bird catches the worm.\",\r\n            \"The pen is mightier than the sword.\" \r\n        };\r\n\r\n        // Split the sentence into an array of words\r\n        // and select those whose first letter is a vowel.\r\n        var earlyBirdQuery =\r\n            from sentence in strings\r\n            let words = sentence.Split(\' \')\r\n            from word in words\r\n            let w = word.ToLower()\r\n            where w[0] == \'a\' || w[0] == \'e\'\r\n                || w[0] == \'i\' || w[0] == \'o\'\r\n                || w[0] == \'u\'\r\n            select word;\r\n\r\n        // Execute the query.\r\n        foreach (var v in earlyBirdQuery)\r\n        {\r\n            Console.WriteLine(\"\\\"{0}\\\" starts with a vowel\", v);\r\n        }\r\n\r\n        // Keep the console window open in debug mode.\r\n        Console.WriteLine(\"Press any key to exit.\");\r\n        Console.ReadKey();\r\n    }\r\n}" },
            {95,"The ascending contextual keyword is used in the orderby clause in query expressions to specify that the sort order is from smallest to largest. Because ascending is the default sort order, you do not have to specify it." +
                "\r\nIEnumerable<string> sortAscendingQuery =\r\n    from vegetable in vegetables\r\n    orderby vegetable ascending\r\n    select vegetable;" },
            {96,"The descending contextual keyword is used in the orderby clause in query expressions to specify that the sort order is from largest to smallest." +
                "\r\nIEnumerable<string> sortDescendingQuery =\r\n    from vegetable in vegetables\r\n    orderby vegetable descending\r\n    select vegetable;" },
            {97,"The on contextual keyword is used in the join clause of a query expression to specify the join condition." +
                "\r\nvar innerJoinQuery =\r\n    from category in categories\r\n    join prod in products on category.ID equals prod.CategoryID\r\n    select new { ProductName = prod.Name, Category = category.Name };" },
            {98,"The equals contextual keyword is used in a join clause in a query expression to compare the elements of two sequences." +
                "\r\nvar innerJoinQuery =\r\n    from category in categories\r\n    join prod in products on category.ID equals prod.CategoryID\r\n    select new { ProductName = prod.Name, Category = category.Name };" },
            {99,"The by contextual keyword is used in the group clause in a query expression to specify how the returned items should be grouped." +
                "\r\nvar query = from student in students\r\n            group student by student.LastName[0];" },
            {100,"The in contextual keyword is used in three contexts:\r\nforeach statements\r\njoin clauses in query expressions\r\ngeneric type parameters in generic interfaces and delegates." }
            

        };
      
        [Java.Interop.Export("button_OnClick")]
		public void button_OnClick(View view)
		{
			var button = view as Android.Widget.Button;
			ChangeBackground (view);
			switch (button.Text)
			{
				case "Types":
					CreateButton(Typesstr);
					break;
				case "Modifiers":
					CreateButton(Modifiers);
					break;
				case "Statement \nKeywords":
					CreateButton(Statement);
					break;
				case "Method \nParameters":
					CreateButton(Method);
					break;
				case "Namespace \nKeywords":
					CreateButton(Namespace);
					break;
				case "Operator \nKeywords":
					CreateButton(Operator);
					break;
				case "Conversion \nKeywords":
					CreateButton(Conversion);
					break;
				case "Access \nKeywords":
					CreateButton(Access);
					break;
				case "Literal \nKeywords":
					CreateButton(Literal);
					break;
				case "Contextual \nKeywords":
					CreateButton(Contextual);
					break;
				case "Query \nKeywords(LINQ)":
					CreateButton(Query);
					break;
			}
		}

		void CreateButton(Dictionary<int, string> myDictionary)
		{
            var linearLayoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MatchParent,
                                                       ViewGroup.LayoutParams.MatchParent);
            linearLayoutParams.Height = 100;
            linearLayoutParams.TopMargin = 10;
            linearLayoutParams.BottomMargin = 10;

            var liner = FindViewById<LinearLayout>(Resource.Id.linearLayout1);
			liner.RemoveAllViews();
			foreach (var str in myDictionary)
			{
				var btn = new Button(this)
				{ Text = str.Value, Id = str.Key };
                btn.SetBackgroundResource(Resource.Drawable.oldDesignDown);
                btn.LayoutParameters = linearLayoutParams;
                btn.SetTextColor(Resource.Color.Black);
                btn.Click += Btn_Click;
				liner.AddView(btn);
			}
		}

		private void Btn_Click(object sender, System.EventArgs e)
		{
			var button = sender as Button;
            if (oldBtn.Id == button.Id)
            {
                button.SetBackgroundResource(Resource.Drawable.newDesignDown);
            }
            else
            {
                button.SetBackgroundResource(Resource.Drawable.newDesignDown);
                oldBtn.SetBackgroundResource(Resource.Drawable.oldDesignDown);
                oldBtn = FindViewById<Button>(button.Id);
            }
			var text = FindViewById<TextView>(Resource.Id.textView1);
			text.MovementMethod = new Android.Text.Method.ScrollingMovementMethod();
			text.Text = Type[button.Id];
		}

		private void ChangeBackground(View view)
		{
			if (oldBtn2.Id == view.Id)
			{
				view.SetBackgroundResource(Resource.Drawable.newDesignTop);
			}
			else
			{
				view.SetBackgroundResource(Resource.Drawable.newDesignTop);
				oldBtn2.SetBackgroundResource(Resource.Drawable.oldDesignTop);
				oldBtn2 = FindViewById<Button>(view.Id);
			}
		}
	}
}